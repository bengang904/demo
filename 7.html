<!DOCTYPE html>
<html>
<head>
  <title>WebXR 地面检测示例</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>body,html{margin:0;overflow:hidden;height:100%;background:#000;}</style>
</head>
<body>
  <button id="start-ar" style="position:absolute;top:20px;left:20px;z-index:1;padding:10px 20px;">开始 AR</button>
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
  <script>
    let renderer, scene, camera, reticle, controller, xrSession, hitTestSource;
    let cube;

    const startButton = document.getElementById('start-ar');

    startButton.addEventListener('click', async () => {
      if (navigator.xr) {
        if (await navigator.xr.isSessionSupported('immersive-ar')) {
          startButton.style.display = 'none';
          startAR();
        } else {
          alert('设备不支持 immersive-ar 会话');
        }
      } else {
        alert('浏览器不支持 WebXR');
      }
    });

    async function startAR() {
      xrSession = await navigator.xr.requestSession('immersive-ar', {
        requiredFeatures: ['hit-test']
      });

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);

      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera();

      // 添加灯光
      const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
      light.position.set(0.5, 1, 0.25);
      scene.add(light);

      // 放置指示器 (reticle)
      const ringGeometry = new THREE.RingGeometry(0.1, 0.12, 32).rotateX(-Math.PI / 2);
      const ringMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
      reticle = new THREE.Mesh(ringGeometry, ringMaterial);
      reticle.visible = false;
      scene.add(reticle);

      // 创建一个立方体，初始隐藏
      const cubeGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
      const cubeMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
      cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
      cube.visible = false;
      scene.add(cube);

      // 设置XR渲染和session
      renderer.xr.setReferenceSpaceType('local');
      await renderer.xr.setSession(xrSession);

      // 请求hit test source
      const viewerSpace = await xrSession.requestReferenceSpace('viewer');
      hitTestSource = await xrSession.requestHitTestSource({ space: viewerSpace });

      xrSession.addEventListener('end', () => {
        hitTestSource = null;
        reticle.visible = false;
        cube.visible = false;
        if (renderer.domElement) document.body.removeChild(renderer.domElement);
        startButton.style.display = 'block';
      });

      renderer.setAnimationLoop(onXRFrame);
    }

    function onXRFrame(time, frame) {
      const session = frame.session;
      const referenceSpace = renderer.xr.getReferenceSpace();
      const pose = frame.getViewerPose(referenceSpace);

      if (pose) {
        const hitTestResults = frame.getHitTestResults(hitTestSource);
        if (hitTestResults.length > 0) {
          const hit = hitTestResults[0];
          const hitPose = hit.getPose(referenceSpace);

          reticle.visible = true;
          reticle.position.set(hitPose.transform.position.x, hitPose.transform.position.y, hitPose.transform.position.z);
          reticle.updateMatrixWorld(true);

          // 让立方体跟随reticle位置显示
          cube.visible = true;
          cube.position.copy(reticle.position);
        } else {
          reticle.visible = false;
          cube.visible = false;
        }
      }
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
